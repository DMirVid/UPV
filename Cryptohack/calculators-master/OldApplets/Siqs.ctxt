#BlueJ class context
comment0.target=Siqs
comment1.params=ecmApplet\ onlyFactoring\ NumberLength\ numberThreads
comment1.target=Siqs(factorApplet,\ boolean,\ int,\ int)
comment10.params=matrixBLength\ startTime
comment10.target=void\ ShowSIQSStatus(int,\ long)
comment11.params=nbrPrimes\ matrixB\ vectLeftHandSide\ vectExpParity\ primeTrialDivisionData
comment11.target=int\ EraseSingletons(int,\ int[][],\ int[][],\ int[],\ PrimeTrialDivisionData[])
comment12.params=nbrPrimes\ matrixB\ primeTrialDivisionData\ vectExpParity\ vectLeftHandSide\ biT\ biR\ biU\ NumberLength
comment12.target=boolean\ LinearAlgebraPhase(int,\ int[][],\ PrimeTrialDivisionData[],\ int[],\ int[][],\ int[],\ int[],\ int[],\ int)
comment12.text=
comment13.params=NbrMod\ Expon\ currentPrime
comment13.target=long\ modPow(long,\ long,\ long)
comment14.params=matrixB\ rowMatrixB\ vectLeftHandSide\ biT\ biU\ biR\ NumberLength
comment14.target=boolean\ InsertNewRelation(int[][],\ int[],\ int[][],\ int[],\ int[],\ int[],\ int)
comment15.params=NbrMod\ currentPrime
comment15.target=int\ modInv(int,\ int)
comment16.params=LeftMatr\ RightMatr\ ProdMatr
comment16.target=void\ MatrixMultAdd(int[],\ int[],\ int[])
comment16.text=The\ product\ matrix\ has\ size\ m\ x\ 32.\ Then\ add\ it\ to\ a\ m\ x\ 32\ matrix.
comment17.params=LeftMatr\ RightMatr\ ProdMatr
comment17.target=void\ MatrixMultiplication(int[],\ int[],\ int[])
comment17.text=The\ product\ matrix\ has\ size\ m\ x\ 32
comment18.params=LeftMatr\ RightMatr\ ProdMatr
comment18.target=void\ MatrTranspMult(int[],\ int[],\ int[])
comment18.text=The\ product\ matrix\ has\ size\ 32\ x\ 32
comment19.params=leftMatr\ rightMatr\ sumMatr
comment19.target=void\ MatrixAddition(int[],\ int[],\ int[])
comment2.params=primeSieveData\ SieveArray\ nbrPrimes\ nbrPrimes2\ firstLimit\ secondLimit\ thirdLimit\ smallPrimeUpperLimit\ threshold\ multiplier\ SieveLimit\ amodq\ PolynomialIndex\ aindex\ nbrFactorsA\ log2\ biLinearCoeff\ NumberLength
comment2.target=void\ PerformSiqsSieveStage(PrimeSieveData[],\ short[],\ int,\ int,\ int,\ int,\ int,\ int,\ byte,\ int,\ int,\ int[],\ int,\ int[],\ int,\ byte,\ int[],\ int)
comment20.params=Matr\ diagS\ Prod
comment20.target=void\ MatrMultBySSt(int[],\ int,\ int[])
comment21.params=matrixB\ Matr\ TempMatr\ ProdMatr\ matrixBlength
comment21.target=void\ MultiplyAByMatrix(int[][],\ int[],\ int[],\ int[],\ int)
comment21.text=factorization\ relations
comment22.params=XmY\ V\ V1\ V2\ col1\ col2
comment22.target=void\ colexchange(int[],\ int[],\ int[],\ int[],\ int,\ int)
comment23.params=XmY\ V\ V1\ V2\ col1\ col2
comment23.target=void\ coladd(int[],\ int[],\ int[],\ int[],\ int,\ int)
comment24.params=matrixB\ matrixBlength
comment24.target=int[]\ BlockLanczos(int[][],\ int)
comment25.params=
comment25.target=void\ run()
comment25.text=
comment26.params=N\ queue
comment26.target=int\ SQUFOF(long,\ int[])
comment26.text=The\ variables\ with\ suffix\ 3\ correspond\ to\ multiplier\ \=\ 3
comment27.params=value
comment27.target=boolean\ isProbablePrime(long)
comment27.text=If\ 2^value\ mod\ value\ \=\ 2,\ then\ the\ value\ is\ a\ probable\ prime\ (value\ odd)
comment3.params=primeSieveData\ primeTrialDivisionData\ nbrPrimes\ rowMatrixBbeforeMerge\ aindex\ nbrFactorsA\ index2\ biDividend\ rowSquares\ NumberLength\ biT\ oddPolynomial
comment3.target=long\ PerformTrialDivision(PrimeSieveData[],\ PrimeTrialDivisionData[],\ int,\ int[],\ int[],\ int,\ int,\ int[],\ int[],\ int,\ int[],\ boolean)
comment4.params=aindex\ nbrFactorsA\ rowMatrixB\ rowMatrixBeforeMerge\ primeTrialDivisionData\ rowSquares
comment4.target=void\ mergeArrays(int[],\ int,\ int[],\ int[],\ PrimeTrialDivisionData[],\ int[])
comment5.params=positive\ matrixB\ rowMatrixB\ rowMatrixBbeforeMerge\ SieveLimit\ vectExpParity\ vectLeftHandSide\ index2\ primeTrialDivisionData\ startTime\ aindex\ nbrFactorsA\ rowSquares\ biLinearCoeff\ NumberLength\ biT\ biU\ biR\ oddPolynomial
comment5.target=void\ SmoothRelationFound(boolean,\ int[][],\ int[],\ int[],\ int,\ int[],\ int[][],\ int,\ PrimeTrialDivisionData[],\ long,\ int[],\ int,\ int[],\ int[],\ int,\ int[],\ int[],\ int[],\ boolean)
comment6.params=positive\ matrixB\ rowMatrixB\ rowMatrixBbeforeMerge\ SieveLimit\ vectExpParity\ vectLeftHandSide\ index2\ primeTrialDivisionData\ startTime\ aindex\ nbrFactorsA\ Divid\ rowPartials\ matrixPartial\ matrixPartialHashIndex\ indexMinFactorA\ rowSquares\ biLinearCoeff\ NumberLength\ biT\ biR\ biU\ biV\ indexFactorsA\ oddPolynomial
comment6.target=void\ PartialRelationFound(boolean,\ int[][],\ int[],\ int[],\ int,\ int[],\ int[][],\ int,\ PrimeTrialDivisionData[],\ long,\ int[],\ int,\ long,\ int[],\ int[][],\ int[],\ int,\ int[],\ int[],\ int,\ int[],\ int[],\ int[],\ int[],\ int[],\ boolean)
comment7.params=matrixB\ rowMatrixB\ rowMatrixBbeforeMerge\ SieveLimit\ vectExpParity\ vectLeftHandSide\ index2\ primeSieveData\ primeTrialDivisionData\ startTime\ aindex\ nbrFactorsA\ rowPartials\ matrixPartial\ matrixPartialHashIndex\ afact\ largePrimeUpperBound\ indexMinFactorA\ multiplier\ rowSquares\ biDividend\ NumberLength\ biT\ biLinearCoeff\ biR\ biU\ biV\ indexFactorsA\ oddPolynomial
comment7.target=void\ SieveLocationHit(int[][],\ int[],\ int[],\ int,\ int[],\ int[][],\ int,\ PrimeSieveData[],\ PrimeTrialDivisionData[],\ long,\ int[],\ int,\ int[],\ int[][],\ int[],\ long[],\ long,\ int,\ int,\ int[],\ int[],\ int,\ int[],\ int[],\ int[],\ int[],\ int[],\ int[],\ boolean)
comment8.params=seed\ nbrFactorsA\ aindex\ indexMinFactorA
comment8.target=long\ getFactorsOfA(long,\ int,\ int[],\ int)
comment9.params=NbrToFactor
comment9.target=java.math.BigInteger\ FactoringSIQS(java.math.BigInteger)
comment9.text=
numComments=28
